// =============================================================================
// STRUCTURED BOTTLENECK
// Generated by Claude from raw founder input
// =============================================================================

export interface StructuredBottleneck {
  // Core problem identification
  problemArchetype: ProblemArchetype;
  problemStatement: string; // One-sentence distillation

  // Constraint mapping
  constraints: Constraint[];

  // Context
  urgency: Urgency;
  stageContext: StageContext;

  // What they've already tried (important for avoiding redundant advice)
  attemptedSolutions: AttemptedSolution[];

  // Success criteria (for measuring match quality)
  successCriteria: {
    description: string;
    timeframe: string; // e.g., "14 days"
    measurable: boolean;
  };

  // Extracted metadata
  signals: {
    hasProductMarketFit: boolean | null;
    hasRevenue: boolean | null;
    isTechnicalProblem: boolean;
    isGTMProblem: boolean;
    isPeopleProblem: boolean;
    isOperationalProblem: boolean;
    isFundraisingProblem: boolean;
  };
}

export interface ProblemArchetype {
  // High-level category
  category:
    | 'FINDING_PMF'
    | 'FIRST_CUSTOMERS'
    | 'SCALING_SALES'
    | 'HIRING_KEY_ROLE'
    | 'TEAM_DYNAMICS'
    | 'TECHNICAL_ARCHITECTURE'
    | 'FUNDRAISING'
    | 'UNIT_ECONOMICS'
    | 'MARKET_POSITIONING'
    | 'CHANNEL_STRATEGY'
    | 'PRODUCT_PRIORITIZATION'
    | 'OPERATIONAL_SCALING'
    | 'PIVOTING'
    | 'OTHER';

  // Specific pattern within category
  subPattern: string;

  // Natural language description of the shape
  shapeDescription: string;
}

export interface Constraint {
  type:
    | 'BUDGET'
    | 'TIME'
    | 'TEAM_SIZE'
    | 'TECHNICAL_DEBT'
    | 'MARKET_TIMING'
    | 'REGULATORY'
    | 'GEOGRAPHIC'
    | 'COMPETITIVE'
    | 'FOUNDER_EXPERIENCE'
    | 'EXISTING_COMMITMENTS'
    | 'OTHER';

  description: string;
  severity: 'HARD' | 'SOFT'; // Hard = non-negotiable, Soft = preference
}

export type Urgency = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';

export interface StageContext {
  stage: 'PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH';
  teamSize: number | null;
  monthsOfRunway: number | null;
  hasProduct: boolean;
  hasRevenue: boolean;
  hasFunding: boolean;
}

export interface AttemptedSolution {
  description: string;
  outcome: string;
  whyItFailed: string | null;
}

// =============================================================================
// STRUCTURED EXPERIENCE
// Generated by Claude from mentor narrative
// =============================================================================

export interface StructuredExperience {
  // Core problem that was solved
  problemArchetype: ProblemArchetype;
  problemStatement: string;

  // Context when problem occurred
  context: ExperienceContext;

  // The journey
  constraints: Constraint[];
  failedApproaches: FailedApproach[];
  successfulApproach: SuccessfulApproach;

  // Outcomes
  outcomes: Outcome[];

  // Transferable insights
  insights: Insight[];

  // Matching metadata
  applicability: {
    stageRange: ['PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH', 'PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH'];
    industrySpecific: boolean;
    industries: string[];
    timeSensitivity: 'EVERGREEN' | 'DATED' | 'CONTEXT_DEPENDENT';
  };
}

export interface ExperienceContext {
  stage: 'PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH';
  teamSize: number | null;
  yearOccurred: number;
  companyType: string; // e.g., "B2B SaaS", "Consumer marketplace"
  role: string; // Mentor's role at the time
  hadFunding: boolean;
  hadRevenue: boolean;
}

export interface FailedApproach {
  description: string;
  whyItFailed: string;
  lessonLearned: string;
}

export interface SuccessfulApproach {
  description: string;
  keyActions: string[];
  whyItWorked: string;
  timeToResults: string;
}

export interface Outcome {
  metric: string;
  before: string;
  after: string;
  timeframe: string;
}

export interface Insight {
  insight: string;
  whenApplicable: string;
  whenNotApplicable: string;
}

// =============================================================================
// MATCH REASONING
// Stored for auditability and learning
// =============================================================================

export interface MatchReasoning {
  // Component scores (each 0-100)
  scores: {
    problemShapeSimilarity: number;
    constraintAlignment: number;
    stageRelevance: number;
    experienceDepth: number;
    recency: number;
  };

  // Weights used (for learning loop adjustment)
  weights: {
    problemShapeSimilarity: number;
    constraintAlignment: number;
    stageRelevance: number;
    experienceDepth: number;
    recency: number;
  };

  // Reasoning for each component
  componentReasoning: {
    problemShapeSimilarity: string;
    constraintAlignment: string;
    stageRelevance: string;
    experienceDepth: string;
    recency: string;
  };

  // Key alignments (for explanation generation)
  keyAlignments: string[];

  // Potential concerns
  concerns: string[];

  // Confidence factors
  confidenceFactors: {
    dataQuality: 'HIGH' | 'MEDIUM' | 'LOW';
    archetypeClarity: 'HIGH' | 'MEDIUM' | 'LOW';
    constraintOverlap: 'HIGH' | 'MEDIUM' | 'LOW';
  };
}

// =============================================================================
// API TYPES
// =============================================================================

export interface BottleneckSubmission {
  startupId: string;
  rawBlocker: string;
  rawAttempts: string;
  rawSuccessCriteria: string;
  stage?: 'PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH';
  teamSize?: number;
  productMaturity?: 'IDEA' | 'PROTOTYPE' | 'MVP' | 'EARLY_REVENUE' | 'SCALING';
}

export interface ExperienceSubmission {
  mentorId: string;
  rawProblem: string;
  rawContext: string;
  rawSolution: string;
  rawOutcomes: string;
  yearOccurred?: number;
  companyStage?: 'PRE_SEED' | 'SEED' | 'SERIES_A' | 'SERIES_B_PLUS' | 'GROWTH';
}

export interface MatchResult {
  matchId: string;
  mentorId: string;
  mentorName: string;
  experienceId: string;
  score: number;
  confidence: 'HIGH' | 'MEDIUM' | 'LOW';
  explanation: string;
  reasoning: MatchReasoning;
}

export interface FeedbackSubmission {
  matchId: string;
  rating: 'HIGHLY_USEFUL' | 'SOMEWHAT_USEFUL' | 'NOT_USEFUL';
  wasRelevant?: boolean;
  wasActionable?: boolean;
  wouldRecommend?: boolean;
  founderNotes?: string;
  operatorNotes?: string;
}
